{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n\nvar legacyModifiers;\n\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\n\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\n\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n\n  const {\n    type,\n    descriptor,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  } = readNextDescriptor(text);\n  const keyDef = (_options$keyboardMap$ = options.keyboardMap.find(def => {\n    if (type === '[') {\n      var _def$code;\n\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n\n      const key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : {\n    key: 'Unknown',\n    code: 'Unknown',\n    [type === '[' ? 'code' : 'key']: descriptor\n  };\n  return {\n    keyDef,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  };\n}\n\nfunction readNextDescriptor(text) {\n  let pos = 0;\n  const startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\\\${startBracket}+`))[0].length : 0;\n  const isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  const type = isEscapedChar ? '' : startBracket;\n  return {\n    type,\n    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))\n  };\n}\n\nfunction readPrintableChar(text, pos) {\n  const descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\n\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n\n  const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  const descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  const repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  const expectedEndBracket = bracketDict[startBracket];\n  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `\"${expectedEndBracket}\"`].filter(Boolean).join(' or '), text[pos], text));\n  }\n\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\n\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\n\nfunction getEnumValue(f, key) {\n  return f[key];\n}\n\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n\n  if (repeatModifier) {\n    return false;\n  }\n\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\n\nfunction getErrorMessage(expected, found, text) {\n  return `Expected ${expected} but found \"${found != null ? found : ''}\" in \"${text}\"\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\n    for more information about how userEvent parses your input.`;\n}","map":{"version":3,"sources":["C:/Users/HP/my-ppp/node_modules/@testing-library/user-event/dist/keyboard/getNextKeyDef.js"],"names":["Object","defineProperty","exports","value","getNextKeyDef","bracketDict","legacyModifiers","legacyKeyMap","text","options","_options$keyboardMap$","type","descriptor","consumedLength","releasePrevious","releaseSelf","repeat","readNextDescriptor","keyDef","keyboardMap","find","def","_def$code","code","toLowerCase","_def$key","key","mapLegacyKey","pos","startBracket","length","startBracketRepeated","match","RegExp","isEscapedChar","readPrintableChar","readTag","assertDescriptor","_text$slice$match","_text$slice$match$","_text$slice$match2","releasePreviousModifier","slice","repeatModifier","releaseSelfModifier","expectedEndBracket","endBracket","Error","getErrorMessage","filter","Boolean","join","Math","max","Number","substr","hasReleaseSelf","getEnumValue","f","_getEnumValue","expected","found"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n\nvar legacyModifiers;\n\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\n\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\n\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n\n  const {\n    type,\n    descriptor,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  } = readNextDescriptor(text);\n  const keyDef = (_options$keyboardMap$ = options.keyboardMap.find(def => {\n    if (type === '[') {\n      var _def$code;\n\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n\n      const key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : {\n    key: 'Unknown',\n    code: 'Unknown',\n    [type === '[' ? 'code' : 'key']: descriptor\n  };\n  return {\n    keyDef,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  };\n}\n\nfunction readNextDescriptor(text) {\n  let pos = 0;\n  const startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\\\${startBracket}+`))[0].length : 0;\n  const isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  const type = isEscapedChar ? '' : startBracket;\n  return {\n    type,\n    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))\n  };\n}\n\nfunction readPrintableChar(text, pos) {\n  const descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\n\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n\n  const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  const descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  const repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  const expectedEndBracket = bracketDict[startBracket];\n  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `\"${expectedEndBracket}\"`].filter(Boolean).join(' or '), text[pos], text));\n  }\n\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\n\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\n\nfunction getEnumValue(f, key) {\n  return f[key];\n}\n\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n\n  if (repeatModifier) {\n    return false;\n  }\n\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\n\nfunction getErrorMessage(expected, found, text) {\n  return `Expected ${expected} but found \"${found != null ? found : ''}\" in \"${text}\"\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\n    for more information about how userEvent parses your input.`;\n}"]},"metadata":{},"sourceType":"script"}