{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keypressBehavior = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _shared = require(\"../shared\");\n\nvar _utils = require(\"../../utils\");\n/**\n * This file should cover the behavior for keys that produce character input\n */\n\n\nconst keypressBehavior = [{\n  matches: (keyDef, element) => {\n    var _keyDef$key;\n\n    return ((_keyDef$key = keyDef.key) == null ? void 0 : _keyDef$key.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'time',\n      readOnly: false\n    });\n  },\n  handle: (keyDef, element, options, state) => {\n    var _state$carryValue;\n\n    let newEntry = keyDef.key;\n    const textToBeTyped = ((_state$carryValue = state.carryValue) != null ? _state$carryValue : '') + newEntry;\n    const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n\n    if ((0, _utils.isValidInputTimeValue)(element, timeNewEntry)) {\n      newEntry = timeNewEntry;\n    }\n\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(newEntry, element);\n    const prevValue = (0, _utils.getValue)(element); // this check was provided by fireInputEventIfNeeded\n    // TODO: verify if it is even needed by this handler\n\n    if (prevValue !== newValue) {\n      (0, _shared.fireInputEvent)(element, {\n        newValue,\n        newSelectionStart,\n        eventOverrides: {\n          data: keyDef.key,\n          inputType: 'insertText'\n        }\n      });\n    }\n\n    (0, _shared.fireChangeForInputTimeIfValid)(element, prevValue, timeNewEntry);\n    state.carryValue = textToBeTyped;\n  }\n}, {\n  matches: (keyDef, element) => {\n    var _keyDef$key2;\n\n    return ((_keyDef$key2 = keyDef.key) == null ? void 0 : _keyDef$key2.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'date',\n      readOnly: false\n    });\n  },\n  handle: (keyDef, element, options, state) => {\n    var _state$carryValue2;\n\n    let newEntry = keyDef.key;\n    const textToBeTyped = ((_state$carryValue2 = state.carryValue) != null ? _state$carryValue2 : '') + newEntry;\n    const isValidToBeTyped = (0, _utils.isValidDateValue)(element, textToBeTyped);\n\n    if (isValidToBeTyped) {\n      newEntry = textToBeTyped;\n    }\n\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(newEntry, element);\n    const prevValue = (0, _utils.getValue)(element); // this check was provided by fireInputEventIfNeeded\n    // TODO: verify if it is even needed by this handler\n\n    if (prevValue !== newValue) {\n      (0, _shared.fireInputEvent)(element, {\n        newValue,\n        newSelectionStart,\n        eventOverrides: {\n          data: keyDef.key,\n          inputType: 'insertText'\n        }\n      });\n    }\n\n    if (isValidToBeTyped) {\n      _dom.fireEvent.change(element, {\n        target: {\n          value: textToBeTyped\n        }\n      });\n    }\n\n    state.carryValue = textToBeTyped;\n  }\n}, {\n  matches: (keyDef, element) => {\n    var _keyDef$key3;\n\n    return ((_keyDef$key3 = keyDef.key) == null ? void 0 : _keyDef$key3.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'number',\n      readOnly: false\n    });\n  },\n  handle: (keyDef, element, options, state) => {\n    var _ref, _state$carryValue3, _newValue$match, _newValue$match2;\n\n    if (!/[\\d.\\-e]/.test(keyDef.key)) {\n      return;\n    }\n\n    const oldValue = (_ref = (_state$carryValue3 = state.carryValue) != null ? _state$carryValue3 : (0, _utils.getValue)(element)) != null ? _ref :\n    /* istanbul ignore next */\n    '';\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(keyDef.key, element, oldValue); // the browser allows some invalid input but not others\n    // it allows up to two '-' at any place before any 'e' or one directly following 'e'\n    // it allows one '.' at any place before e\n\n    const valueParts = newValue.split('e', 2);\n\n    if (Number((_newValue$match = newValue.match(/-/g)) == null ? void 0 : _newValue$match.length) > 2 || Number((_newValue$match2 = newValue.match(/\\./g)) == null ? void 0 : _newValue$match2.length) > 1 || valueParts[1] && !/^-?\\d*$/.test(valueParts[1])) {\n      return;\n    }\n\n    (0, _shared.fireInputEvent)(element, {\n      newValue,\n      newSelectionStart,\n      eventOverrides: {\n        data: keyDef.key,\n        inputType: 'insertText'\n      }\n    });\n    const appliedValue = (0, _utils.getValue)(element);\n\n    if (appliedValue === newValue) {\n      state.carryValue = undefined;\n    } else {\n      state.carryValue = newValue;\n    }\n  }\n}, {\n  matches: (keyDef, element) => {\n    var _keyDef$key4;\n\n    return ((_keyDef$key4 = keyDef.key) == null ? void 0 : _keyDef$key4.length) === 1 && ((0, _utils.isElementType)(element, ['input', 'textarea'], {\n      readOnly: false\n    }) && !(0, _utils.isClickableInput)(element) || (0, _utils.isContentEditable)(element)) && (0, _utils.getSpaceUntilMaxLength)(element) !== 0;\n  },\n  handle: (keyDef, element) => {\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(keyDef.key, element);\n    (0, _shared.fireInputEvent)(element, {\n      newValue,\n      newSelectionStart,\n      eventOverrides: {\n        data: keyDef.key,\n        inputType: 'insertText'\n      }\n    });\n  }\n}, {\n  matches: (keyDef, element) => keyDef.key === 'Enter' && ((0, _utils.isElementType)(element, 'textarea', {\n    readOnly: false\n  }) || (0, _utils.isContentEditable)(element)) && (0, _utils.getSpaceUntilMaxLength)(element) !== 0,\n  handle: (keyDef, element, options, state) => {\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)('\\n', element);\n    const inputType = (0, _utils.isContentEditable)(element) && !state.modifiers.shift ? 'insertParagraph' : 'insertLineBreak';\n    (0, _shared.fireInputEvent)(element, {\n      newValue,\n      newSelectionStart,\n      eventOverrides: {\n        inputType\n      }\n    });\n  }\n}];\nexports.keypressBehavior = keypressBehavior;","map":{"version":3,"sources":["C:/Users/HP/my-ppp/node_modules/@testing-library/user-event/dist/keyboard/plugins/character.js"],"names":["Object","defineProperty","exports","value","keypressBehavior","_dom","require","_shared","_utils","matches","keyDef","element","_keyDef$key","key","length","isElementType","type","readOnly","handle","options","state","_state$carryValue","newEntry","textToBeTyped","carryValue","timeNewEntry","buildTimeValue","isValidInputTimeValue","newValue","newSelectionStart","calculateNewValue","prevValue","getValue","fireInputEvent","eventOverrides","data","inputType","fireChangeForInputTimeIfValid","_keyDef$key2","_state$carryValue2","isValidToBeTyped","isValidDateValue","fireEvent","change","target","_keyDef$key3","_ref","_state$carryValue3","_newValue$match","_newValue$match2","test","oldValue","valueParts","split","Number","match","appliedValue","undefined","_keyDef$key4","isClickableInput","isContentEditable","getSpaceUntilMaxLength","modifiers","shift"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keypressBehavior = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _shared = require(\"../shared\");\n\nvar _utils = require(\"../../utils\");\n\n/**\n * This file should cover the behavior for keys that produce character input\n */\nconst keypressBehavior = [{\n  matches: (keyDef, element) => {\n    var _keyDef$key;\n\n    return ((_keyDef$key = keyDef.key) == null ? void 0 : _keyDef$key.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'time',\n      readOnly: false\n    });\n  },\n  handle: (keyDef, element, options, state) => {\n    var _state$carryValue;\n\n    let newEntry = keyDef.key;\n    const textToBeTyped = ((_state$carryValue = state.carryValue) != null ? _state$carryValue : '') + newEntry;\n    const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n\n    if ((0, _utils.isValidInputTimeValue)(element, timeNewEntry)) {\n      newEntry = timeNewEntry;\n    }\n\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(newEntry, element);\n    const prevValue = (0, _utils.getValue)(element); // this check was provided by fireInputEventIfNeeded\n    // TODO: verify if it is even needed by this handler\n\n    if (prevValue !== newValue) {\n      (0, _shared.fireInputEvent)(element, {\n        newValue,\n        newSelectionStart,\n        eventOverrides: {\n          data: keyDef.key,\n          inputType: 'insertText'\n        }\n      });\n    }\n\n    (0, _shared.fireChangeForInputTimeIfValid)(element, prevValue, timeNewEntry);\n    state.carryValue = textToBeTyped;\n  }\n}, {\n  matches: (keyDef, element) => {\n    var _keyDef$key2;\n\n    return ((_keyDef$key2 = keyDef.key) == null ? void 0 : _keyDef$key2.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'date',\n      readOnly: false\n    });\n  },\n  handle: (keyDef, element, options, state) => {\n    var _state$carryValue2;\n\n    let newEntry = keyDef.key;\n    const textToBeTyped = ((_state$carryValue2 = state.carryValue) != null ? _state$carryValue2 : '') + newEntry;\n    const isValidToBeTyped = (0, _utils.isValidDateValue)(element, textToBeTyped);\n\n    if (isValidToBeTyped) {\n      newEntry = textToBeTyped;\n    }\n\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(newEntry, element);\n    const prevValue = (0, _utils.getValue)(element); // this check was provided by fireInputEventIfNeeded\n    // TODO: verify if it is even needed by this handler\n\n    if (prevValue !== newValue) {\n      (0, _shared.fireInputEvent)(element, {\n        newValue,\n        newSelectionStart,\n        eventOverrides: {\n          data: keyDef.key,\n          inputType: 'insertText'\n        }\n      });\n    }\n\n    if (isValidToBeTyped) {\n      _dom.fireEvent.change(element, {\n        target: {\n          value: textToBeTyped\n        }\n      });\n    }\n\n    state.carryValue = textToBeTyped;\n  }\n}, {\n  matches: (keyDef, element) => {\n    var _keyDef$key3;\n\n    return ((_keyDef$key3 = keyDef.key) == null ? void 0 : _keyDef$key3.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'number',\n      readOnly: false\n    });\n  },\n  handle: (keyDef, element, options, state) => {\n    var _ref, _state$carryValue3, _newValue$match, _newValue$match2;\n\n    if (!/[\\d.\\-e]/.test(keyDef.key)) {\n      return;\n    }\n\n    const oldValue = (_ref = (_state$carryValue3 = state.carryValue) != null ? _state$carryValue3 : (0, _utils.getValue)(element)) != null ? _ref :\n    /* istanbul ignore next */\n    '';\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(keyDef.key, element, oldValue); // the browser allows some invalid input but not others\n    // it allows up to two '-' at any place before any 'e' or one directly following 'e'\n    // it allows one '.' at any place before e\n\n    const valueParts = newValue.split('e', 2);\n\n    if (Number((_newValue$match = newValue.match(/-/g)) == null ? void 0 : _newValue$match.length) > 2 || Number((_newValue$match2 = newValue.match(/\\./g)) == null ? void 0 : _newValue$match2.length) > 1 || valueParts[1] && !/^-?\\d*$/.test(valueParts[1])) {\n      return;\n    }\n\n    (0, _shared.fireInputEvent)(element, {\n      newValue,\n      newSelectionStart,\n      eventOverrides: {\n        data: keyDef.key,\n        inputType: 'insertText'\n      }\n    });\n    const appliedValue = (0, _utils.getValue)(element);\n\n    if (appliedValue === newValue) {\n      state.carryValue = undefined;\n    } else {\n      state.carryValue = newValue;\n    }\n  }\n}, {\n  matches: (keyDef, element) => {\n    var _keyDef$key4;\n\n    return ((_keyDef$key4 = keyDef.key) == null ? void 0 : _keyDef$key4.length) === 1 && ((0, _utils.isElementType)(element, ['input', 'textarea'], {\n      readOnly: false\n    }) && !(0, _utils.isClickableInput)(element) || (0, _utils.isContentEditable)(element)) && (0, _utils.getSpaceUntilMaxLength)(element) !== 0;\n  },\n  handle: (keyDef, element) => {\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)(keyDef.key, element);\n    (0, _shared.fireInputEvent)(element, {\n      newValue,\n      newSelectionStart,\n      eventOverrides: {\n        data: keyDef.key,\n        inputType: 'insertText'\n      }\n    });\n  }\n}, {\n  matches: (keyDef, element) => keyDef.key === 'Enter' && ((0, _utils.isElementType)(element, 'textarea', {\n    readOnly: false\n  }) || (0, _utils.isContentEditable)(element)) && (0, _utils.getSpaceUntilMaxLength)(element) !== 0,\n  handle: (keyDef, element, options, state) => {\n    const {\n      newValue,\n      newSelectionStart\n    } = (0, _utils.calculateNewValue)('\\n', element);\n    const inputType = (0, _utils.isContentEditable)(element) && !state.modifiers.shift ? 'insertParagraph' : 'insertLineBreak';\n    (0, _shared.fireInputEvent)(element, {\n      newValue,\n      newSelectionStart,\n      eventOverrides: {\n        inputType\n      }\n    });\n  }\n}];\nexports.keypressBehavior = keypressBehavior;"]},"metadata":{},"sourceType":"script"}